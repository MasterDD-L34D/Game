name: QA export manual

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Numero PR su cui pubblicare il commento (opzionale)'
        required: false

jobs:
  export:
    name: Run QA export
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f tools/py/requirements.txt ]; then
            python -m pip install -r tools/py/requirements.txt
          fi

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Generate QA reports
        run: node scripts/export-qa-report.js

      - name: Upload QA artifacts
        uses: actions/upload-artifact@v4
        with:
          name: qa-reports-${{ github.run_id }}
          path: |
            reports/qa_badges.json
            reports/trait_baseline.json
            reports/generator_validation.json
            reports/qa-changelog.md
          if-no-files-found: error

      - name: Post QA badge comment
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const { pathToFileURL } = require('url');

            function safeColor(value) {
              if (!value) return 'blue';
              return String(value).replace(/[^a-zA-Z0-9_-]/g, '') || 'blue';
            }

            function encodeSegment(value) {
              return encodeURIComponent(String(value).replace(/\s+/g, ' ').trim());
            }

            const badgesPath = path.join(process.env.GITHUB_WORKSPACE, 'reports', 'qa_badges.json');
            const badgePayload = JSON.parse(fs.readFileSync(badgesPath, 'utf8'));
            let highlightSummary = null;
            try {
              const formatterModule = await import(
                pathToFileURL(path.join(process.env.GITHUB_WORKSPACE, 'webapp/src/services/qaHighlightFormatter.js'))
              );
              if (formatterModule?.buildQaHighlightsSummary) {
                highlightSummary = formatterModule.buildQaHighlightsSummary(badgePayload, { limit: 6 });
              }
            } catch (error) {
              core.warning(`Impossibile caricare il formatter QA: ${error.message || error}`);
            }

            const badges = highlightSummary?.badges || [];
            const badgeLine = badges.length
              ? badges
                  .map((badge) =>
                    `![${badge.label} ${badge.value}](https://img.shields.io/badge/${encodeSegment(badge.label)}-${encodeSegment(badge.value)}-${safeColor(badge.color)})`,
                  )
                  .join(' ')
              : '_Badge non disponibili_';

            const highlightSections = highlightSummary?.sections || [];
            const highlights = [];
            for (const section of highlightSections) {
              if (!section.items || !section.items.length) continue;
              highlights.push(`- **${section.title} (${section.total})**: ${section.items.join(', ')}`);
            }
            if (!highlights.length) {
              highlights.push('- Nessun highlight critico.');
            }

            const topConflicts = highlightSummary?.topConflicts || [];
            const conflictLines = topConflicts.length
              ? ['**Top conflitti**', ...topConflicts.map((entry) => `- ${entry.id || 'n/d'}: ${entry.conflicts}`)]
              : [];

            const generatedAt = highlightSummary?.generatedAt || badgePayload.generated_at || new Date().toISOString();
            const artifactLinks = [
              `[Trait baseline](./reports/trait_baseline.json)`,
              `[Generator validation](./reports/generator_validation.json)`,
              `[QA changelog](./reports/qa-changelog.md)`,
            ].join(' Â· ');

            const bodyLines = [
              '<!-- qa-export-comment -->',
              `### QA Export (${generatedAt})`,
              '',
              badgeLine,
              '',
              '**Highlights**',
              ...highlights,
            ];

            if (conflictLines.length) {
              bodyLines.push('', ...conflictLines);
            }

            bodyLines.push('', `Artefatti: ${artifactLinks}`);

            const body = bodyLines.join('\n');

            const prNumber = process.env.PR_NUMBER ? Number(process.env.PR_NUMBER) : null;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            if (prNumber) {
              const { data: comments } = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: prNumber,
                per_page: 100,
              });
              const existing = comments.find((comment) => comment.body && comment.body.includes('<!-- qa-export-comment -->'));
              if (existing) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: existing.id,
                  body,
                });
              } else {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prNumber,
                  body,
                });
              }
            } else {
              const commitSha = context.sha;
              const { data: commitComments } = await github.rest.repos.listCommentsForCommit({
                owner,
                repo,
                commit_sha: commitSha,
                per_page: 100,
              });
              const existing = commitComments.find(
                (comment) => comment.body && comment.body.includes('<!-- qa-export-comment -->'),
              );
              if (existing) {
                await github.rest.repos.updateCommitComment({
                  owner,
                  repo,
                  comment_id: existing.id,
                  body,
                });
              } else {
                await github.rest.repos.createCommitComment({
                  owner,
                  repo,
                  commit_sha: commitSha,
                  body,
                });
              }
            }

            core.summary.addHeading('QA export');
            core.summary.addRaw(badgeLine);
            core.summary.addEOL();
            core.summary.addList(highlights.map((line) => line.replace(/^-\s*/, '')));
            await core.summary.write();
